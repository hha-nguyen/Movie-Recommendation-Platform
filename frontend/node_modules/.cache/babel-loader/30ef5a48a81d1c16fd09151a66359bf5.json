{"ast":null,"code":"const SemVer = require('../classes/semver');\n\nconst parse = require('./parse');\n\nconst {\n  safeRe: re,\n  t\n} = require('../internal/re');\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  options = options || {};\n  let match = null;\n\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];\n    let next;\n\n    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;\n    } // leave it in a clean state\n\n\n    coerceRtlRegex.lastIndex = -1;\n  }\n\n  if (match === null) {\n    return null;\n  }\n\n  const major = match[2];\n  const minor = match[3] || '0';\n  const patch = match[4] || '0';\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);\n};\n\nmodule.exports = coerce;","map":{"version":3,"sources":["/home/mesto/Projects/Movie-Recommendation-Platform/frontend/node_modules/jsonwebtoken/node_modules/semver/functions/coerce.js"],"names":["SemVer","require","parse","safeRe","re","t","coerce","version","options","String","match","rtl","includePrerelease","COERCEFULL","COERCE","coerceRtlRegex","COERCERTLFULL","COERCERTL","next","exec","index","length","lastIndex","major","minor","patch","prerelease","build","module","exports"],"mappings":"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","sourcesContent":["const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n"]},"metadata":{},"sourceType":"script"}